import * as THREE from "./build/three.module.js";
import {ResourceTracker} from "./ResourceTracker.js";
// import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.17/+esm";
import GUI from "./build/lil-gui.esm.js";
import {OrbitControls} from "./build/OrbitControls.js";
import * as BufferGeometryUtils from "./build/BufferGeometryUtils.js";
import {AxisGridHelper} from "./build/minigui.js";
import {Lut} from "./build/Lut.js";
import {CONFIG_DICT} from "./ConfigDicts.js";
import {Geometree, Quadrant3D} from "./Octree.js";
import {
    Brick,
    BrickO2,
    Tetrahedral,
    TetrahedralO2,
    Lineal,
    Triangular,
    TriangularO2,
    Quadrilateral,
    Serendipity,
    LinealO2,
} from "./Elements.js";
import {
    max,
    min,
    transpose
} from "./math.js";
import {NotificationBar} from "./NotificationBar.js";

function allowUpdate() {
    return new Promise((f) => {
        setTimeout(f, 0);
    });
}

var style = getComputedStyle(document.body);
var TEXT_COLOR = style.getPropertyValue("--gui-text-color").trim();
var BACKGROUND_COLOR = style.getPropertyValue("--gui-background-color").trim();
var TITLE_BACKGROUND_COLOR = style
    .getPropertyValue("--gui-title-background-color")
    .trim();
var PLOT_GRID_COLOR = style.getPropertyValue("--plot-grid-color").trim();
var FONT_FAMILY = style.getPropertyValue("--font-family").trim();
var FOCUS_COLOR = style.getPropertyValue("--focus-color").trim();
var LINES_COLOR = style.getPropertyValue("--gui-text-color").trim();

var PLOT_STYLE = {
    margin: {t: 0},
    paper_bgcolor: BACKGROUND_COLOR,
    plot_bgcolor: BACKGROUND_COLOR,
    font: {
        color: TEXT_COLOR,
        family: FONT_FAMILY,
    },
    xaxis: {
        gridcolor: PLOT_GRID_COLOR,
    },
    yaxis: {
        gridcolor: PLOT_GRID_COLOR,
    },
};

const types = {
    B1V: Brick,
    B2V: BrickO2,
    TE1V: Tetrahedral,
    TE2V: TetrahedralO2,
    L1V: Lineal,
    T1V: Triangular,
    T2V: TriangularO2,
    C1V: Quadrilateral,
    C2V: Serendipity,
    L2V: LinealO2,
};

const themes = {
    "默认": {},
    "透明": {
        "--gui-background-color": "#f6f6f6",
        "--gui-text-color": "#3d3d3d",
        "--gui-title-background-color": "#efefef",
        "--gui-title-text-color": "#3d3d3d",
        "--gui-widget-color": "#eaeaea",
        "--gui-hover-color": "#f0f0f0",
        "--gui-focus-color": "#fafafa",
        "--gui-number-color": "#07aacf",
        "--gui-string-color": "#8da300",
        "--focus-color": "#dc2c41",
        "--backbround-color": "transparent",
        emmisive: true,
    },
    "明亮": {
        "--gui-background-color": "#f6f6f6",
        "--gui-text-color": "#3d3d3d",
        "--gui-title-background-color": "#efefef",
        "--gui-title-text-color": "#3d3d3d",
        "--gui-widget-color": "#eaeaea",
        "--gui-hover-color": "#f0f0f0",
        "--gui-focus-color": "#fafafa",
        "--gui-number-color": "#07aacf",
        "--gui-string-color": "#8da300",
        "--focus-color": "#dc2c41",
        emmisive: true,
    },
    "黑暗": {
        "--gui-background-color": "#1f1f1f",
        "--gui-text-color": "#ebebeb",
        "--gui-title-background-color": "#111111",
        "--gui-title-text-color": "#ebebeb",
        "--gui-widget-color": "#424242",
        "--gui-hover-color": "#4f4f4f",
        "--gui-focus-color": "#595959",
        "--gui-number-color": "#2cc9ff",
        "--gui-string-color": "#a2db3c",
        "--focus-color": "var(--gui-focus-color)",
        "--plot-grid-color": "#616161",
    },
    "半明亮": {
        "--gui-background-color": "#fdf6e3",
        "--gui-text-color": "#657b83",
        "--gui-title-background-color": "#f5efdc",
        "--gui-title-text-color": "#657b83",
        "--gui-widget-color": "#eee8d5",
        "--gui-hover-color": "#e7e1cf",
        "--gui-focus-color": "#e6ddc7",
        "--gui-number-color": "#2aa0f3",
        "--gui-string-color": "#97ad00",
        "--focus-color": "var(--gui-focus-color)",
    },
    "半黑暗": {
        "--gui-background-color": "#002b36",
        "--gui-text-color": "#b2c2c2",
        "--gui-title-background-color": "#001f27",
        "--gui-title-text-color": "#b2c2c2",
        "--gui-widget-color": "#094e5f",
        "--gui-hover-color": "#0a6277",
        "--gui-focus-color": "#0b6c84",
        "--gui-number-color": "#2aa0f2",
        "--gui-string-color": "#97ad00",
        "--focus-color": "var(--gui-focus-color)",
        "--plot-grid-color": "#616161",
    },
    "黄绿": {
        "--gui-background-color": "#32405e",
        "--gui-text-color": "#ebe193",
        "--gui-title-background-color": "#713154",
        "--gui-title-text-color": "#ffffff",
        "--gui-widget-color": "#057170",
        "--gui-hover-color": "#057170",
        "--gui-focus-color": "#b74f88",
        "--gui-number-color": "#ddfcff",
        "--gui-string-color": "#ffbf00",
        "--focus-color": "var(--gui-focus-color)",
        "--plot-grid-color": "#616161",
    },
};

const styleElement = document.createElement("style");
document.body.appendChild(styleElement);

class FEMViewer {
    constructor(container, magnification, rot, axis = false, iz = 1.05) {
        if (!magnification) {
            magnification = 0;
        }
        // FEM
        this.selectedNodes = [];
        this.regions = [];
        this.nodeSearchRadius = 0.01;

        this.container = container;
        let canvas = document.createElement("canvas");
        canvas.setAttribute("class", "box side-pane");
        canvas.setAttribute("willReadFrequently", "true");
        this.container.appendChild(canvas);
        this.canvas = canvas;

        this.loaderIcon = document.createElement("div");
        this.loaderIcon.setAttribute("class", "loaderIcon");
        this.container.appendChild(this.loaderIcon);

        this.theme = themes["默认"];
        this.element_views = new Set();
        this.refreshing = true;
        this.wireframe = false;
        this.corriendo = false;
        this.animationFrameID = undefined;
        this.min_search_radius = -Infinity;
        this.not_draw_elements = [];
        this.max_color_value = 0;
        this.min_color_value = 0;
        this.initial_zoom = iz;
        this.solution_as_displacement = false;
        this.axis = axis;
        this.max_color_value_slider = undefined;
        this.min_color_value_slider = undefined;
        this.resource_tracker = new ResourceTracker();
        this.raycaster = new THREE.Raycaster();
        this.notiBar = new NotificationBar(this.container);

        this.before_load = () => {
            this.loaderIcon.style.display = "";
        };
        this.after_load = () => {
            this.loaderIcon.style.display = "none";
        };
        this.rot = rot;
        this.resolution = 1;
        this.nodes = [];
        this.selectedNodesMesh = {};
        this.nvn = -1;
        this.dictionary = [];
        this.types = [];
        this.solutions = [];
        this.solutions_info = [];
        this.U = [];
        this.step = 0;
        this.max_disp = 0.0;
        this.size = 0.0;
        this.elements = [];
        this.info = "";
        this.infoDetail = "";
        this.ndim = -1;
        this.border_elements = [];
        this.config_dict = CONFIG_DICT["GENERAL"];
        this.dimensions = ["x", "y", "z"];

        // THREE JS
        this.renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true,
            alpha: true,
        });
        this.renderer.autoClear = false;

        this.not_draw_elements = [];
        this.delta = 0;
        this.interval = 1 / 12;
        this.clock = new THREE.Clock();
        this.bufferGeometries = [];
        this.bufferLines = [];
        this.model = new THREE.Object3D();

        this.regionModel = new THREE.Object3D();
        this.regionModelContours = new THREE.Object3D();
        this.regionModelGeometries = new THREE.Object3D();
        this.invisibleModel = new THREE.Object3D();
        this.colors = false;
        this.animate = true;
        this.magnification = magnification;
        this.mult = 1.0;
        this.side = 1.0;
        this.max_disp = 0.0;
        this.draw_lines = true;
        this.colormap = "冷热图";
        this.show_model = true;
        this.octreeMesh = undefined;
        this.showOctree = false;
        this.regionModel.visible = false;

        this.MenuClosed = true;

        this.lut = new Lut(this.colormap);
        this.filename = "";

        this.gui = new GUI({title: "根目录", container: this.container});
        this.gui.close();
        this.loaded = false;
        this.colorOptions = "nocolor";
        this.clickMode = "无";
        // this.createModals();
        this.histogram = document.getElementById("histogram");

        this.settings();
        this.createListeners();
    }

    createListeners() {
        window.addEventListener("resize", this.render.bind(this));

        document.addEventListener("visibilitychange", (e) =>
            this.handleVisibilityChange(e)
        );

        this.notiBar.addButton("fa fa-refresh", this.reload.bind(this));
        this.playButton = this.notiBar.addButton(
            "fa fa-pause",
            this.toggleRefresh.bind(this)
        );
    }

    updateMenuClosed() {
        this.gui.show(this.MenuClosed);
        if (this.MenuClosed) {
            document
                .getElementById("notification-container")
                .setAttribute("style", "");
        } else {
            document
                .getElementById("notification-container")
                .setAttribute("style", "visibility: hidden");
        }
    }

    updateStylesheet() {
        let style = "";
        const stylesheet = this.theme;
        for (let prop in stylesheet) {
            const value = stylesheet[prop];
            style += `\t${prop}: ${value};\n`;
        }
        if (style) {
            style = ":root {\n" + style + "}";
            styleElement.innerHTML = style;
        } else {
            styleElement.innerHTML = "";
        }
    }

    updateColors() {
        style = getComputedStyle(document.body);
        TEXT_COLOR = style.getPropertyValue("--gui-text-color").trim();
        BACKGROUND_COLOR = style
            .getPropertyValue("--gui-background-color")
            .trim();
        TITLE_BACKGROUND_COLOR = style
            .getPropertyValue("--gui-title-background-color")
            .trim();
        PLOT_GRID_COLOR = style.getPropertyValue("--plot-grid-color").trim();
        FONT_FAMILY = style.getPropertyValue("--font-family").trim();
        FOCUS_COLOR = style.getPropertyValue("--focus-color").trim();
        LINES_COLOR = style.getPropertyValue("--gui-text-color").trim();

        PLOT_STYLE = {
            margin: {t: 0},
            paper_bgcolor: BACKGROUND_COLOR,
            plot_bgcolor: BACKGROUND_COLOR,
            font: {
                color: TEXT_COLOR,
                family: FONT_FAMILY,
            },
            xaxis: {
                gridcolor: PLOT_GRID_COLOR,
            },
            yaxis: {
                gridcolor: PLOT_GRID_COLOR,
            },
        };
    }

    updateTheme() {
        this.updateStylesheet();
        this.updateColors();
        this.updateMaterial();
        this.updateGeometry();
    }

    updateResolution() {
        for (const e of this.elements) {
            e.res = this.resolution;
            e.initGeometry();
            this.updateSpecificBufferGeometry(e.index);
        }
        this.updateSolution();
    }

    updateRefresh() {
        this.controls.enabled = this.refreshing;
        if (this.refreshing) {
            this.playButton.setAttribute(
                "class",
                "fa fa-pause notification-action"
            );
        } else {
            this.playButton.setAttribute(
                "class",
                "fa fa-play notification-action"
            );
        }
    }

    toggleRefresh() {
        this.refreshing = !this.refreshing;
        this.updateRefresh();
        if (this.refreshing) {
            this.animationFrameID = requestAnimationFrame(
                this.update.bind(this)
            );
        } else {
            cancelAnimationFrame(this.animationFrameID);
        }

        return this.refreshing;
    }

    isNeighbor(ide1, ide2) {
        const e1 = this.elements[ide1];
        const e2 = this.elements[ide2];
        let MIN_VERTICES = 3;
        let en_comun = 0;
        for (const c1 of e1.coords) {
            for (const c2 of e2.coords) {
                if (c2 === c1) {
                    en_comun += 1;
                    if (en_comun >= MIN_VERTICES) {
                        return true;
                    }
                    break;
                }
            }
        }
        return false;
    }

    isBorder(e) {
        let nfaces = this.elements[e["id"]].nfaces;
        let neighbors = 0;
        let potential = this.OctTree.query_range_point_radius(
            e["_xcenter"],
            this.min_search_radius
        );
        let nb = [];
        for (const ie2 of potential) {
            if (e["id"] !== ie2["id"]) {
                if (this.isNeighbor(e["id"], ie2["id"])) {
                    neighbors += 1;
                    nb.push(ie2);
                    if (neighbors === nfaces) {
                        break;
                    }
                }
            }
        }
        if (neighbors < nfaces) {
            return [true, nb];
        }
        return [false, potential];
    }

    createOctree() {
        this.notiBar.setMessage("创建八叉树... ⌛");
        let nnodes = this._nodes.map((x) => {
            return x["_xcenter"];
        });
        let nodes = transpose(nnodes);
        let center_x = (max(nodes[0]) + min(nodes[0])) / 2;
        let size_x = (max(nodes[0]) - min(nodes[0])) / 2;
        let center_y = (max(nodes[1]) + min(nodes[1])) / 2;
        let size_y = (max(nodes[1]) - min(nodes[1])) / 2;
        let center_z = (max(nodes[2]) + min(nodes[2])) / 2;
        let size_z = (max(nodes[2]) - min(nodes[2])) / 2;

        let FF = 1.01;
        let dimension = [size_x * FF, size_y * FF, size_z * FF];
        let bounding = new Quadrant3D([center_x, center_y, center_z], dimension);
        this.OctTree = new Geometree(bounding, 10);
        for (let i = 0; i < this._nodes.length; i++) {
            let p = {
                _xcenter: this._nodes[i]["_xcenter"].slice(),
                id: this._nodes[i]["id"],
            };
            this.OctTree.add_point(p);
            this.notiBar.sendMessage("八叉树创建完成");
        }
        const geo_list = this.OctTree.giveContours(this.norm);
        const geo = BufferGeometryUtils.mergeBufferGeometries(geo_list, true);
        this.octreeMesh = new THREE.LineSegments(geo, this.line_material);
    }

    async loadJSON(json_path, be) {
        this.notiBar.setMessage("加载模型..." + "⌛", true);
        this.json_path = json_path;
        this.filename = json_path;
        const response = await fetch(this.json_path);
        const jsondata = await response.json();
        if (be !== undefined) {
            jsondata["border_elements"] = be;
        }
        this.parseJSON(jsondata);
        this.notiBar.resetMessage();
    }

    async updateShowOctree() {
        if (this.showOctree) {
            if (!this.octreeMesh) {
                await this.createOctree();
            }
            this.model.add(this.octreeMesh);
        } else {
            this.model.remove(this.octreeMesh);
        }
        this.updateShowModel();
    }

    reset() {
        this.solution_as_displacement = false;
        this.variable_as_displacement = 2;
        this.toggleSolutionAsDisp(); // THIS TOGGLE DISPLACEMENTS!!!
        const track = this.resource_tracker.track.bind(this.resource_tracker);

        track(this.model);
        track(this.invisibleModel);

        for (let i = 0; i < this.elements.length; i++) {
            this.elements[i].geometry.dispose();
            this.bufferGeometries.pop().dispose();
            this.bufferLines.pop().dispose();
        }
        this.mergedGeometry.dispose();
        this.mergedLineGeometry.dispose();
        this.renderer.renderLists.dispose();
        this.material.dispose();
        this.line_material.dispose();

        // this.destroy_element_views();
        this.resource_tracker.dispose();

        if (this.octreeMesh) {
            track(this.octreeMesh);
        }

        for (const sn of this.selectedNodes) {
            for (const smm of this.selectedNodesMesh[sn]) {
                this.model.remove(smm);
                smm.material.dispose();
                smm.geometry.dispose();
            }
        }
        for (let i = 0; i < this.regions.length; i++) {
            let reg = this.regions[i];
            this.regionModelGeometries.remove(reg.mesh);
            this.regionModelContours.remove(reg.edges);
            reg.mesh.material.dispose();
            reg.mesh.geometry.dispose();
            reg.edges.material.dispose();
            reg.edges.geometry.dispose();
        }
        this.regions = [];
        this.selectedNodes = [];
        this.selectedNodesMesh = {};

        this.show_model = true;
        this.showOctree = false;

        this.element_views = new Set();
        this.wireframe = false;
        this.corriendo = false;
        this.animationFrameID = undefined;
        this.animate = false;
        this.colorOptions = "nocolor";
        this.config_dict = CONFIG_DICT["GENERAL"];
        this.min_search_radius = -Infinity;
        this.not_draw_elements = []; // quitar
        this.bufferGeometries = [];
        this.bufferLines = [];

        this.nodes = [];
        this.dictionary = [];
        this.solutions = [];
        this.solutions_info = [];
        this.U = [];
        this.step = 0;
        this.elements = [];
        this.types = [];
        this.magnification = 0.0;
        this.max_abs_disp = undefined;
        this.border_elements = [];
        this.scene.remove(this.model);
        this.regionModel.remove(this.regionModelContours);
        this.regionModel.remove(this.regionModelGeometries);
        this.scene.remove(this.regionModel);
        this.scene.remove(this.invisibleModel);
        delete this.mergedGeometry;
        delete this.mergedLineGeometry;
        this.resource_tracker.untrack(this.model);
        this.resource_tracker.untrack(this.invisibleModel);
        if (this.octreeMesh) {
            this.resource_tracker.untrack(this.octreeMesh);
        }
        this.octreeMesh = undefined;
    }

    settings() {
        THREE.Object3D.DefaultUp = new THREE.Vector3(0, 0, 1);
        // Scene settings
        this.scene = new THREE.Scene();
        // Camera settings
        const fov = 40;
        const aspect = window.innerWidth / window.innerHeight; // the canvas default
        const near = 0.01;
        const far = 200;
        this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        this.camera.position.set(25, 25, 25);
        this.camera.lookAt(0, 0, 0);
        this.scene.add(this.camera);

        // Controls
        this.controls = new OrbitControls(this.camera, this.canvas);
        this.controls.target.set(0, 0, 0);
        this.controls.update();

        // Lights
        this.light2 = new THREE.AmbientLight(0xffffff, 0.0);
        const color = 0xffffff;
        const intensity = 0.8;
        this.light = new THREE.PointLight(color, intensity);
        this.camera.add(this.light);
        this.scene.add(this.light2);

        this.orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 2);
        this.orthoCamera.position.set(-0.9, 0, 1);
        this.uiScene = new THREE.Scene();
        this.sprite = new THREE.Sprite(
            new THREE.SpriteMaterial({
                map: new THREE.CanvasTexture(this.lut.createCanvas()),
            })
        );

        this.sprite.scale.x = 0.02;
        this.uiScene.add(this.sprite);

        this.gh = new AxisGridHelper(this.scene, 0);
        this.gh.visible = this.axis;

        this.guiSettingsBasic();
    }

    async updateShowModel() {
        this.mesh.visible = this.show_model;
        this.contour.visible = this.show_model;
        this.regionModel.visible = this.show_model;
        this.draw_lines = this.show_model;
        this.gh.visible = true;
        for (const ch of this.model.children) {
            if (ch.visible) {
                this.gh.visible = false;
                break;
            }
        }
    }

    guiSettingsBasic() {
        if (this.settingsFolder) {
            this.settingsFolder.destroy();
        }
        this.settingsFolder = this.gui.addFolder("设置");
        this.settingsFolder.add(this.gh, "visible").listen().name("坐标轴");
        this.settingsFolder.add(this, "rot").name("自动旋转").listen();

        this.settingsFolder
            .add(this, "wireframe")
            .listen()
            .onChange(() => {
                this.updateMaterial();
                this.updateGeometry();
            })
            .name("线框");
        this.settingsFolder
            .add(this, "draw_lines")
            .onChange(this.updateLines.bind(this))
            .name("显示线条")
            .listen();

        this.settingsFolder
            .add(this, "showOctree")
            .onChange(this.updateShowOctree.bind(this))
            .listen()
            .name("显示八叉树");
        this.settingsFolder
            .add(this, "show_model")
            .name("显示模型")
            .onChange(this.updateShowModel.bind(this))
            .listen();
        this.settingsFolder
            .add(this.regionModel, "visible")
            .name("显示区域")
            .listen();

        if (this.config_dict["displacements"]) {
        } else {
            if (this.ndim !== 3) {
                this.settingsFolder
                    .add(this, "solution_as_displacement")
                    .listen()
                    .name("变形图")
                    .onFinishChange(this.toggleSolutionAsDisp.bind(this));
            }
        }

        this.settingsFolder
            .add(this, "clickMode", [
                "查看单元",
                "删除单元",
                "发现节点",
                "发现区域",
            ])
            .listen()
            .name("左键点击");
        this.settingsFolder
            .add(this, "resolution", {
                "低 (1)": 1,
                "中 (2)": 2,
                "高 (4)": 3,
                "极高 (8)": 4,
                "最高 (16)": 5,
            })
            .listen()
            .onChange(this.updateResolution.bind(this))
            .name("分辨率");

        this.settingsFolder
            .add(this, "theme", themes, "默认")
            .name("风格")
            .listen()
            .onChange(this.updateTheme.bind(this));
        if (this.example_file_paths) {
            this.settingsFolder
                .add(this, "filename", this.example_file_paths)
                .name("Examples")
                .listen()
                .onChange(this.changeExample.bind(this));
        }
    }

    toggleSolutionAsDisp() {
        this.config_dict["displacements"] = this.solution_as_displacement;
        this.guiSettings();
        if (!this.solution_as_displacement) {
            this.magnification = 0.0;
            this.updateSolutionAsDisplacement();
        } else {
            this.updateVariableAsSolution();
        }
    }

    updateVariableAsSolution() {
        this.animate = false;
        this.mult = 1;
        this.magnification = 0.4 / this.max_abs_disp;
        this.updateDispSlider();
        this.updateSolutionAsDisplacement();
    }

    guiSettings() {
        // GUI
        if (this.disp_gui_sol_disp_folder) {
            this.disp_gui_sol_disp_folder.destroy();
        }
        if (this.solution_as_displacement) {
            this.disp_gui_sol_disp_folder = this.gui.addFolder(
                "Solution as displacement"
            );
            this.disp_gui_sol_disp_folder
                .add(this, "variable_as_displacement", {
                    x: 0,
                    y: 1,
                    z: 2,
                })
                .listen()

                .name("Variabe")
                .onChange(this.updateVariableAsSolution.bind(this));
            this.variable_as_displacement = 2;
        }

        if (this.disp_gui_disp_folder) {
            this.disp_gui_disp_folder.destroy();
        }
        if (this.config_dict["displacements"]) {
            this.disp_gui_disp_folder = this.gui.addFolder("Displacements");
            this.disp_gui_disp_folder
                .add(this, "animate")
                .name("Animation")
                .listen()
                .onChange(() => {
                    this.notiBar.setMessage("Animation running!");

                    if (!this.animate) {
                        this.mult = 1.0;
                        this.updateMeshCoords();
                        this.updateGeometry();
                        this.notiBar.resetMessage();
                    }
                });
            this.magnificationSlider = this.disp_gui_disp_folder
                .add(this, "magnification", 0, 1)
                .name("Disp multiplier")
                .listen()
                .onChange(() => {
                    this.updateMeshCoords();
                    this.updateGeometry();
                });
        }
    }

    async reload() {
        cancelAnimationFrame(this.animationFrameID);

        this.animate = false;
        this.reset();
        this.before_load();
        this.notiBar.setMessage("Reloading model..." + "⌛");
        await this.loadJSON(this.filename);
        this.notiBar.resetMessage();
        await this.init(false);
        this.after_load();
    }

    updateLut() {
        this.lut.setColorMap(this.colormap);
        const map = this.sprite.material.map;
        this.lut.updateCanvas(map.image);
        map.needsUpdate = true;
        this.lut.setMax(this.max_color_value);
        this.lut.setMin(this.min_color_value);
        this.updateMaterial();
        this.updateColorValues();
        this.updateGeometry();
    }

    updateColorVariable() {
        let msg = "";
        const co = this.colorOptions;
        if (co !== "nocolor") {
            this.colors = true;
            msg =
                "显示 " +
                this.color_select_option.$select.value +
                " 云图：";
        } else {
            this.colors = false;
            msg = "";
        }
        let Cfuntion = undefined;
        if (this.config_dict["C"]) {
            Cfuntion = this.config_dict["C"];
        }
        for (const e of this.elements) {
            e.setMaxDispNode(
                this.colorOptions,
                this.config_dict["calculateStrain"],
                Cfuntion
            );
        }

        let max_disp = -Infinity;
        let min_disp = Infinity;
        for (const e of this.elements) {
            const variable = e.colors;
            max_disp = Math.max(max_disp, ...variable);
            min_disp = Math.min(min_disp, ...variable);
        }
        let delta = max_disp - min_disp;
        if (delta === 0) {
            delta = 1;
            max_disp += 0.5;
            min_disp -= 0.5;
        }
        this.max_color_value = max_disp;
        this.min_color_value = min_disp;
        this.max_color_value_slider.step(delta / 1000);
        this.min_color_value_slider.step(delta / 1000);

        this.min_color_value_slider.max(max_disp);
        this.min_color_value_slider.min(min_disp);

        this.max_color_value_slider.max(max_disp);
        this.max_color_value_slider.min(min_disp);
        let max_str = this.max_color_value.toFixed(4);
        let min_str = this.min_color_value.toFixed(4);
        if (Math.abs(max_str) === "0.0000") {
            max_str = this.max_color_value.toExponential(4);
        }
        if (Math.abs(min_str) === "0.0000") {
            min_str = this.min_color_value.toExponential(4);
        }

        msg += " 最大值=" + max_str + " 最小值=" + min_str;
        this.notiBar.setMessage(msg);
        this.updateLut();
    }

    viewFront() {
        this.camera.position.set(1, 0, 0);
        this.camera.lookAt(0, 0, 0);
        this.zoomExtents();
    }

    updateCamera() {
        this.camera.updateProjectionMatrix();
    }

    async renderMath() {
        //function f() {
        //	renderMathInElement(document.body, {
        //		throwOnError: false,
        //	});
        //}
        //setTimeout(f, 100);
    }

    updateMaterial() {
        if (this.colors) {
            this.material = new THREE.MeshBasicMaterial({
                vertexColors: true,
                wireframe: this.wireframe,
                side: THREE.DoubleSide,
            });
            this.light.intensity = 0.0;
            this.light2.intensity = 1.0;
        } else {
            if (this.theme["emmisive"]) {
                this.material = new THREE.MeshLambertMaterial({
                    color: FOCUS_COLOR,
                    emissive: FOCUS_COLOR,
                    wireframe: this.wireframe,
                    side: THREE.DoubleSide,
                });
                this.light.intensity = 1.0;
                this.light2.intensity = 0.0;
            } else {
                this.material = new THREE.MeshBasicMaterial({
                    color: FOCUS_COLOR,
                    wireframe: this.wireframe,
                    side: THREE.DoubleSide,
                });
                this.light.intensity = 0.0;
                this.light2.intensity = 1.0;
            }
        }
        this.line_material = new THREE.LineBasicMaterial({
            color: LINES_COLOR,
            linewidth: 3,
        });
    }

    handleVisibilityChange(e) {
        if (document.visibilityState === "hidden") {
            this.clock.stop();
        } else {
            this.clock.start();
        }
    }

    update() {
        this.delta += this.clock.getDelta();
        if (this.delta > this.interval) {
            // The draw or time dependent code are here
            this.render(this.delta);

            this.delta = this.delta % this.interval;
        }
        this.animationFrameID = requestAnimationFrame(this.update.bind(this));
        this.refreshing = true;
        this.updateRefresh();
    }

    resizeRendererToDisplaySize() {
        const canvas = this.renderer.domElement;
        const pixelRatio = window.devicePixelRatio;
        const width = (canvas.clientWidth * pixelRatio) | 0;
        const height = (canvas.clientHeight * pixelRatio) | 0;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
            this.renderer.setSize(width, height, false);
        }
        return needResize;
    }

    updateMeshCoords() {
        for (let i = 0; i < this.elements.length; i++) {
            const e = this.elements[i];
            if (this.draw_lines) {
                e.setGeometryCoords(this.magnification * this.mult, this.norm);
            } else {
                e.setGeometryCoords(this.magnification * this.mult, this.norm);
            }
        }
        if (this.colors) {
            this.updateColorValues();
        }
    }

    updateSpecificBufferGeometry(i) {
        this.bufferGeometries[i] = this.elements[i].geometry;
        this.bufferLines[i] = this.elements[i].line_geometry;
        this.invisibleModel.children[i].geometry = this.elements[i].geometry;
    }

    updateColorValues() {
        for (let i = 0; i < this.elements.length; i++) {
            const e = this.elements[i];
            const colors = this.bufferGeometries[i].attributes.color;
            for (let j = 0; j < e.domain.length; j++) {
                let disp = e.colors[j];
                const color = this.lut.getColor(disp);
                colors.setXYZ(j, color.r, color.g, color.b);
            }
        }
    }

    updateGeometry() {
        if (this.octreeMesh) {
            this.octreeMesh.material = this.line_material;
            this.octreeMesh.material.needsUpdate = true;
        }
        for (const sn of this.selectedNodes) {
            for (const smm of this.selectedNodesMesh[sn]) {
                smm.material = this.line_material;
                smm.material.needsUpdate = true;
            }
        }

        for (const reg of this.regions) {
            reg.mesh.material = this.material;
            reg.mesh.material.needsUpdate = true;
            reg.edges.material = this.line_material;
            reg.edges.material.needsUpdate = true;
        }

        this.mergedGeometry.dispose();
        this.mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(
            this.bufferGeometries,
            false
        );
        this.mesh.geometry = this.mergedGeometry;
        this.mesh.material = this.material;
        this.mesh.material.needsUpdate = true;

        if (this.draw_lines) {
            this.mergedLineGeometry.dispose();
            this.mergedLineGeometry = BufferGeometryUtils.mergeBufferGeometries(
                this.bufferLines,
                false
            );
            this.contour.geometry = this.mergedLineGeometry;
            this.contour.material = this.line_material;
            this.contour.material.needsUpdate = true;
        }
        for (const ev of this.element_views) {
            ev.updateGeometry();
        }
    }

    rotateModel() {
        this.model.rotation.z += 0.005;
    }

    async render(time) {
        if (typeof time == "number") {
            time = time || 0;
        } else {
            time = 0.0;
        }
        this.mult += time * this.side;
        if (this.mult > 1) {
            this.side = -1.0;
            this.mult = 1.0;
        } else if (this.mult < -1) {
            this.side = 1.0;
            this.mult = -1.0;
        }
        if (!this.animate) {
            this.mult = 1.0;
        }

        // console.log(this.mult);

        // Specific part of shit
        if (this.rot) {
            this.rotateModel();
        } else {
            if (this.animate) {
                this.updateMeshCoords();
                this.updateGeometry();
            }
        }
        if (this.resizeRendererToDisplaySize()) {
            const canvas = this.renderer.domElement;
            const aspect = canvas.clientWidth / canvas.clientHeight;
            this.camera.aspect = aspect;
            this.camera.updateProjectionMatrix();
            this.zoomExtents();
        }
        this.renderer.render(this.scene, this.camera);
        if (this.colors && this.MenuClosed) {
            this.renderer.render(this.uiScene, this.orthoCamera);
        }
    }

    changeExample() {
        this.gui.close();
        this.json_path = this.filename;
        this.reload();
    }

    zoomExtents() {
        let vFoV = this.camera.getEffectiveFOV();
        let hFoV = this.camera.fov * this.camera.aspect;

        let FoV = Math.min(vFoV, hFoV);
        let FoV2 = FoV / 2;

        let dir = new THREE.Vector3();
        this.camera.getWorldDirection(dir);

        let bb = this.mesh.geometry.boundingBox;
        let bs = this.mesh.geometry.boundingSphere;
        let bsWorld = bs.center.clone();
        this.mesh.localToWorld(bsWorld);

        let th = (FoV2 * Math.PI) / 180.0;
        let sina = Math.sin(th);
        let R = bs.radius;
        let FL = R / sina;

        let cameraDir = new THREE.Vector3();
        this.camera.getWorldDirection(cameraDir);

        let cameraOffs = cameraDir.clone();
        cameraOffs.multiplyScalar(-FL * this.initial_zoom);
        let newCameraPos = bsWorld.clone().add(cameraOffs);

        this.camera.position.copy(newCameraPos);
        this.camera.lookAt(bsWorld);
        this.controls.target.copy(bsWorld);

        this.controls.update();
    }

    updateLines() {
        if (this.draw_lines) {
            this.model.add(this.contour);
        } else {
            this.model.remove(this.contour);
        }
        this.updateGeometry();
    }

    guiSolutions() {
        if (this.guifolder) {
            this.guifolder.destroy();
        }
        this.guifolder = this.gui.addFolder("后处理");
        this.settingsFolder
            .add(this, "viewFront")
            .name("正视图");
        this.color_select_option = this.guifolder
            .add(this, "colorOptions", {
                "无": "nocolor",
                "|U|": "dispmag",
                "A": "A",
                "Scaled Jacobian": "scaled_jac",
                ...this.config_dict["dict"],
                ...this.prop_dict_names,
            })
            .name("云图")
            .listen()
            .onChange(this.updateColorVariable.bind(this))
            .onFinishChange(this.renderMath.bind(this));
        this.guifolder
            .add(this, "colormap", [
                "彩虹色",
                "冷热图",
                "热力图",
                "灰度图",
            ])
            .listen()
            .name("颜色")
            .onChange(this.updateLut.bind(this));
        this.max_color_value_slider = this.guifolder
            .add(this, "max_color_value", 0.0, 1.0)
            .name("最大值")
            .listen()
            .onChange(this.updateLut.bind(this));
        this.min_color_value_slider = this.guifolder
            .add(this, "min_color_value", 0.0, 1.0)
            .name("最小值")
            .listen()
            .onChange(this.updateLut.bind(this));
        this.guifolder
            .add(this, "step", this.solutions_info_str)
            .onChange(this.updateSolution.bind(this))
            .listen()
            .name("帧");
    }

    async init(animate = true) {
        this.guiSettingsBasic();
        this.guiSettings();
        this.guiSolutions();
        this.animate = animate;
        if (!this.config_dict["displacements"]) {
            this.animate = false;
        }
        await this.createElements();
        // console.log(this.elements[0])
        this.createLines();
        this.mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(
            this.bufferGeometries,
            true
        );
        this.notiBar.setMessage("创建材料..." + "⌛");
        await allowUpdate();
        this.updateMaterial();
        this.mergedLineGeometry = BufferGeometryUtils.mergeBufferGeometries(
            this.bufferLines,
            true
        );
        this.contour = new THREE.LineSegments(
            this.mergedLineGeometry,
            this.line_material
        );
        // this.model.add(this.contour);
        this.mesh = new THREE.Mesh(this.mergedGeometry, this.material);
        this.notiBar.setMessage("生成网格..." + "⌛");
        await allowUpdate();

        this.updateU();
        this.model.add(this.mesh);
        // this.regionModel.add(this.regionModelContours);
        // this.regionModel.add(this.regionModelGeometries);
        // this.model.add(this.regionModel);

        this.scene.add(this.model);
        this.scene.add(this.invisibleModel);

        this.updateLines();
        if (!this.corriendo) {
            this.corriendo = true;
            this.animationFrameID = requestAnimationFrame(
                this.update.bind(this)
            );
            this.refreshing = true;
            this.updateRefresh();
        }
        this.renderer.render(this.scene, this.camera);
        this.zoomExtents();

        this.notiBar.setMessage("绘制模型..." + "⌛");
        await allowUpdate();
        // let geo = new THREE.SphereGeometry(this.nodeSearchRadius / 2, 8, 8);
        // this.meshSelectedNode = new THREE.LineSegments(
        //     new THREE.EdgesGeometry(geo),
        //     this.line_material
        // );
        // this.meshSelectedNode.visible = false;
        // this.model.add(this.meshSelectedNode);
        this.notiBar.setMessage("加载完成");
        await allowUpdate();
    }

    giveRegionsAsCoords() {
        let r = [];
        for (const reg of this.regions) {
            let region = [];
            for (const cord of reg.coordinates) {
                let coordenada = [];
                for (let i = 0; i < this.ndim; i++) {
                    coordenada.push(cord[i] + this.dimens[i]);
                }
                region.push(coordenada);
            }
            r.push(region);
        }
        return r;
    }

    setStep(step) {
        this.step = step;
        this.updateU();
        this.updateMeshCoords();
        this.updateGeometry();
    }

    parseJSON(jsondata) {
        this.norm = 1.0 / max(jsondata["nodes"].flat());
        this.nodes = [];
        this.nodes = jsondata["nodes"];

        this.nvn = jsondata["nvn"];
        this.ndim = this.nodes[0].length;
        for (let i = 0; i < this.nodes.length; i++) {
            for (let j = this.nodes[i].length; j < 3; j++) {
                this.nodes[i].push(0.0); //Coordinate completion
            }
        }
        this.regiones = jsondata["regions"];
        for (const re of this.regiones) {
            for (const co of re) {
                for (let j = co.length; j < 3; j++) {
                    co.push(0.0); //Coordinate completion for regions
                }
            }
        }
        this.dictionary = [];
        this.types = [];
        this.solutions_info = [];
        this.solutions = [];
        this.outputFields = [];
        this.original_dict = jsondata["dictionary"];
        this.dictionary.push(...this.original_dict);
        this.types = jsondata["types"];
        if (jsondata["border_elements"]) {
            this.border_elements.push(...jsondata["border_elements"]);
            this.dictionary = [];
            for (const be of this.border_elements) {
                this.dictionary.push(this.original_dict[be]);
            }
        }
        if (!jsondata["solutions"]) {
            if (!jsondata["disp_field"] || jsondata["disp_field"].length === 0) {
                this.solutions = [
                    Array(this.nodes.length * this.nvn).fill(0.0),
                ];
                this.solutions_info = [{info: "Not solved"}];
            } else {
                this.solutions.push(...jsondata["disp_field"]);
                this.solutions_info = [];
                for (let i = 0; i < this.solutions.length; i++) {
                    this.solutions_info.push({
                        info: "Not info",
                        index: i,
                    });
                }
            }
        } else {
            if (jsondata["solutions"].length === 0) {
                this.solutions = [
                    Array(this.nodes.length * this.nvn).fill(0.0),
                ];
                this.solutions_info = [{info: "Not solved"}];
            }
            for (let i = 0; i < jsondata["solutions"].length; i++) {
                let solution = jsondata["solutions"][i];
                this.solutions.push(solution["U"]);
                this.solutions_info.push({...solution["info"], index: i});
                this.outputFields.push(solution["V"]);
            }
        }
        this.solutions_info_str = [];
        for (let i = 0; i < this.solutions_info.length; i++) {
            this.solutions_info_str.push(i);
        }
        this.config_dict = CONFIG_DICT["GENERAL"];
        let d = {};
        let variables = [
            "U",
            "V",
            "W",
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
        ];

        for (let i = 0; i < this.nvn; i++) {
            for (let j = 0; j < this.ndim; j++) {
                d["d" + variables[i] + "/d" + this.dimensions[j]] = [i, j];
            }
        }
        // console.log(d)
        this.config_dict["dict"] = d;
        if (jsondata["properties"]) {
            if (CONFIG_DICT[jsondata["properties"]["problem"]]) {
                this.config_dict = {
                    ...CONFIG_DICT[jsondata["properties"]["problem"]],
                };
            }
        }
        this.prop_dict = {};
        this.prop_dict_names = {};
        for (const p of this.config_dict["props"]) {
            this.prop_dict[p] = ["PROP", jsondata["properties"][p], p];
            this.prop_dict_names[p] = ["PROP", p];
        }

        this.loaded = true;
        this.info = Object.keys(this.solutions_info[this.step])[0];
        this.infoDetail = this.solutions_info[this.step][this.info];

        const secon_coords = this.nodes[0].map((_, colIndex) =>
            this.nodes.map((row) => row[colIndex])
        );

        let size_x = max(secon_coords[0].flat()) - min(secon_coords[0].flat());
        let size_y = max(secon_coords[1].flat()) - min(secon_coords[1].flat());
        let size_z = max(secon_coords[2].flat()) - min(secon_coords[2].flat());

        let center_x = (max(secon_coords[0]) + min(secon_coords[0])) / 2;
        let center_y = (max(secon_coords[1]) + min(secon_coords[1])) / 2;
        let center_z = (max(secon_coords[2]) + min(secon_coords[2])) / 2;
        this.center = [
            center_x - size_x / 2,
            center_y - size_y / 2,
            center_z - size_z / 2,
        ];
        
        this.size = max(this.nodes.flat()) - min(this.nodes.flat());
        this.dimens = [size_x / 2, size_y / 2, size_z / 2];
        this._nodes = [];
        for (let kk = 0; kk < this.nodes.length; kk++) {
            this._nodes.push({_xcenter: this.nodes[kk], id: kk});
        }
        let h = this.size / 20;
        let kk = 0;
        for (const n of this.nodes) {
            if (this.ndim === 1 || this.ndim === 2) {
                let node = [n[0], n[1], n[2] + h];
                this._nodes.push({_xcenter: node, id: kk});
                if (this.ndim === 1) {
                    node = [n[0], n[1] + h, n[2] + h];
                    this._nodes.push({_xcenter: node, id: kk});
                    node = [n[0], n[1] + h, n[2]];
                    this._nodes.push({_xcenter: node, id: kk});
                }
            }
            kk++;
        }
    }


    updateSolutionInfo() {
        this.infoDetail = this.solutions_info[this.step][this.info];
    }

    updateDispSlider() {
        const max_disp = max(this.U);
        const min_disp = min(this.U);
        this.max_abs_disp =
            Math.max(Math.abs(max_disp), Math.abs(min_disp)) * this.norm;
        if (this.config_dict["displacements"]) {
            this.magnificationSlider.min(0.0);
            this.magnificationSlider.max(0.4 / this.max_abs_disp);
        }
    }

    updateU() {
        this.U = this.solutions[this.step].flat();
        this.V = this.outputFields[this.step].flat();

        this.updateDispSlider();

        for (const e of this.elements) {
            e.setUe(
                this.U,
                this.config_dict["calculateStrain"],
                this.config_dict["displacements"]
            );
            e.setOutputField(
                this.V
            );
            if (this.solution_as_displacement) {
                e.variableAsDisplacement(this.variable_as_displacement);
            }
        }
        this.updateMeshCoords();
        this.updateColorVariable();
    }

    nextSolution() {
        this.step += 1 * (this.step < this.solutions.length - 1);
        this.updateSolution();
    }

    updateSolution() {
        this.updateU();
        this.updateGeometry();
        this.updateSolutionInfo();
    }

    updateSolutionAsDisplacement() {
        for (const e of this.elements) {
            if (this.solution_as_displacement) {
                e.variableAsDisplacement(this.variable_as_displacement);
            }
        }
        this.updateMeshCoords();
        this.updateGeometry();
        this.updateSolutionInfo();
    }

    prevSolution() {
        this.step -= 1 * (this.step > 0);
        this.updateSolution();
    }

    async createElements() {
        this.bufferGeometries = [];
        this.elements = new Array(this.dictionary.length).fill(0.0);
        let times = 0;
        for (let i = 0; i < this.dictionary.length; i++) {
            const conns = this.dictionary[i];
            const econns = [];
            for (let i = 0; i < this.nvn; i++) {
                const a = [];
                for (const gdl of conns) {
                    a.push(gdl * this.nvn + i);
                }
                econns.push(a);
            }
            const coords = [];
            for (const node of conns) {
                coords.push(this.nodes[node]);
            }

            this.elements[i] = new types[this.types[i]](
                coords,
                econns,
                this.size * this.norm
            );

            let d = 0;
            for (const c of coords) {
                let sx = c[0] - this.elements[i]._xcenter[0];
                let sy = c[1] - this.elements[i]._xcenter[1];
                let sz = c[2] - this.elements[i]._xcenter[2];
                d = Math.max(d, sx ** 2 + sy ** 2 + sz ** 2);
            }

            this.min_search_radius = Math.max(
                this.min_search_radius,
                2 * d ** 0.5
            );
            const colors = [];
            for (
                let j = 0;
                j < this.elements[i].geometry.attributes.position.count;
                ++j
            ) {
                colors.push(1, 1, 1);
            }
            this.elements[i].index = i;
            const p = {};
            for (const [key, value] of Object.entries(this.prop_dict)) {
                let result = undefined;
                if (value[1] instanceof Array) {
                    result = value[1][i];
                } else {
                    result = value[1];
                }
                p[key] = result;
            }
            this.elements[i].set_properties(p);
            this.bufferGeometries.push(this.elements[i].geometry);
            const messh = new THREE.Mesh(
                this.elements[i].geometry,
                this.material
            );
            messh.visible = false;
            messh.userData = {elementId: i};
            this.invisibleModel.add(messh);

            let percentage = (i / this.dictionary.length) * 100;
            if (percentage > times) {
                times += 1;
                this.notiBar.setProgressBar("加载模型...", percentage);
                await allowUpdate();
            }
        }
    }

    createLines() {
        this.bufferLines = [];
        for (const e of this.elements) {
            this.bufferLines.push(e.line_geometry);
        }
    }
}

export {FEMViewer, themes};
